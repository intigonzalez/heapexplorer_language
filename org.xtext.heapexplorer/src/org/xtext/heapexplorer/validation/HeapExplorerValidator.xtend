/*
 * generated by Xtext
 */
package org.xtext.heapexplorer.validation

import org.eclipse.xtext.validation.Check
import org.xtext.heapexplorer.heapExplorer.Plus
import org.xtext.heapexplorer.heapExplorer.HeapExplorerPackage
import org.xtext.heapexplorer.heapExplorer.NumberLiteral
import org.xtext.heapexplorer.heapExplorer.StringLiteral
import javax.inject.Inject
import org.xtext.heapexplorer.heapExplorer.Minus
import org.xtext.heapexplorer.heapExplorer.MultiOrDiv
import org.xtext.heapexplorer.heapExplorer.AndOrExpression
import org.xtext.heapexplorer.heapExplorer.Comparison
import org.xtext.heapexplorer.heapExplorer.ArithmeticSigned
import org.xtext.heapexplorer.heapExplorer.Equals
import org.xtext.heapexplorer.heapExplorer.Expression
import org.xtext.heapexplorer.heapExplorer.ComponentProperty
import org.xtext.heapexplorer.types.HETypeFactory
import org.xtext.heapexplorer.heapExplorer.Type
import org.xtext.heapexplorer.heapExplorer.BaseType
import org.xtext.heapexplorer.heapExplorer.StructType
import org.xtext.heapexplorer.heapExplorer.TableType
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.emf.ecore.EPackage
import java.util.List
import org.xtext.heapexplorer.heapExplorer.HeapExplorer
import org.xtext.heapexplorer.heapExplorer.HeapExplorerFactory
import org.xtext.heapexplorer.heapExplorer.EntityData
import org.eclipse.emf.ecore.EClass

import org.apache.log4j.Logger
import org.xtext.heapexplorer.heapExplorer.Instance
import org.xtext.heapexplorer.heapExplorer.Atomic
import org.xtext.heapexplorer.heapExplorer.MemberCall
import org.xtext.heapexplorer.types.LambdaFunctionType
import org.xtext.heapexplorer.heapExplorer.Assignament

//import org.eclipse.xtext.validation.Check

/**
 * Custom validation rules. 
 *
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
class HeapExplorerValidator extends AbstractHeapExplorerValidator {
	
	@Inject extension CachedExpressionsTypeProvider
	
	private static final Logger log = Logger.getLogger(typeof(HeapExplorerValidator))

	@Check
	def checkTypeDefinition(Type type) {
		if (type!= null && type.type.equals(HETypeFactory::unknownType)){
			switch (type) {
				BaseType: {
					error("Error defining the type: " + type.name + " in " + type.eResource.URI,
						HeapExplorerPackage$Literals::TYPE__NAME
					)
				}
				StructType: {
					error("Error defining the type" + " in " + type.eResource.URI,
						HeapExplorerPackage$Literals::STRUCT_TYPE__OP
					)
				}
				TableType: {
					error("Error defining the type 111 " + type.type + " " + (type as TableType).base_type  + " in " + type.eResource.URI,
						HeapExplorerPackage$Literals::TABLE_TYPE__OP
					)
				}
				default: {
					error("Error defining the type: " + type.name  + " in " + type.eResource.URI,
						HeapExplorerPackage$Literals::TYPE__NAME
					)
				}
			}
			
		}
	}
	
	
	@Check
	def checkComponentPropertyAssignament(ComponentProperty p) {
		val expected = p.property.type.type
		val observed = p.expression.type
		if (observed instanceof LambdaFunctionType) {
			val l = (observed as LambdaFunctionType)
			val lr = l.returnType
			if (!expected.equals(lr) && !expected.canReceive(lr)) {
					error(String.format("Cannot assign %s to %s. in ", observed, expected, p.eResource.URI),
						HeapExplorerPackage$Literals::COMPONENT_PROPERTY__PROPERTY
					)
			}
			else if (l.params == null || l.params.size > 0)
					error(String.format("Cannot assign %s to %s. in ", observed, expected, p.eResource.URI),
						HeapExplorerPackage$Literals::COMPONENT_PROPERTY__PROPERTY
					)
		}
		else if (!expected.equals(observed) && !expected.canReceive(observed)) {
			error(String.format("Cannot assign %s to %s. in ", observed, expected, p.eResource.URI),
				HeapExplorerPackage$Literals::COMPONENT_PROPERTY__PROPERTY
			)
		}
	}
	
	@Check
	def checkAssignamentWithinLambda(Assignament a) {
		val expected = a.type
		val observed = a.expression.type
		if (observed instanceof LambdaFunctionType) {
			val l = (observed as LambdaFunctionType)
			val lr = l.returnType
			if (!expected.equals(lr) && !expected.canReceive(lr)) {
					error(String.format("Cannot assign %s to %s. in ", observed, expected, a.eResource),
						HeapExplorerPackage$Literals::ASSIGNAMENT__NAME
					)
			}
			else if (l.params == null || l.params.size > 0)
					error(String.format("Cannot assign %s to %s. in ", observed, expected, a.eResource),
						HeapExplorerPackage$Literals::ASSIGNAMENT__NAME
					)
		}
		else if (!expected.equals(observed) && !expected.canReceive(observed)) {
			error(String.format("Cannot assign %s to %s. in ", observed, expected, a.eResource),
				HeapExplorerPackage$Literals::ASSIGNAMENT__NAME
			)
		}
	}
	
	@Check
	def dispatch void checkExpressionType(Expression m) {
		if (!(m instanceof MemberCall) && !(m instanceof Atomic)) {
			if (m!=null && m.type.equals(ExpressionsTypeProvider.unknownType))
				// FIXME the second parameter is wrong 
				error(String.format("Wrong type for grammar element: %s. in", m.eClass.name, m.eResource),
					m.eClass.getEStructuralFeature(
						HeapExplorerPackage$Literals::COMPARISON__OP.name
					)
				)
			
		}
	}
	
	@Check
	def dispatch void checkExpressionType(Instance m) {
		val t = m.names.type
		if (!t.equals(HETypeFactory::stringType) && !HETypeFactory.isCollectionOf(t, HETypeFactory::stringType))
			error("Wrong type for instance's names: " + " in " + m.eResource.URI,
				HeapExplorerPackage$Literals::INSTANCE__NAMES
			)
	}
}

/*
 * generated by Xtext
 */
package org.xtext.heapexplorer.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IGenerator
import org.eclipse.xtext.generator.IFileSystemAccess
import org.xtext.heapexplorer.heapExplorer.Type
import org.xtext.heapexplorer.heapExplorer.BaseType
import org.xtext.heapexplorer.heapExplorer.StructType
import org.xtext.heapexplorer.heapExplorer.TableType
import org.xtext.heapexplorer.heapExplorer.EntityData
import org.xtext.heapexplorer.heapExplorer.GlobalProperty
import org.xtext.heapexplorer.heapExplorer.StringLiteral
import org.apache.log4j.Logger
import org.xtext.heapexplorer.validation.ExpressionsTypeProvider
import javax.inject.Inject
import org.xtext.heapexplorer.types.HETypeFactory
import org.xtext.heapexplorer.validation.ConstantValueExpressionProvider
import org.xtext.heapexplorer.validation.CachedExpressionsTypeProvider
import org.xtext.heapexplorer.heapExplorer.ComponentType
import org.xtext.heapexplorer.heapExplorer.Expression
import org.xtext.heapexplorer.heapExplorer.ComponentProperty
import org.xtext.heapexplorer.heapExplorer.Instance
import org.xtext.heapexplorer.types.CollectionType
import org.xtext.heapexplorer.types.ComposedType
import org.xtext.heapexplorer.types.HeapExplorerType
import org.osgi.framework.FrameworkUtil
import org.eclipse.core.runtime.FileLocator
import org.eclipse.core.runtime.Path
import java.util.HashMap
import org.eclipse.core.resources.IResource
import java.util.List

/**
 * Generates code from your model files on save.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#TutorialCodeGeneration
 */
class HeapExplorerGenerator implements IGenerator {
	
	@Inject extension CachedExpressionsTypeProvider
	@Inject extension ConstantValueExpressionProvider
	@Inject extension ExtensionExpressionCompilationProvider
	@Inject extension ResultsToJavaGenerator
	
	private static final Logger log = Logger.getLogger(typeof(HeapExplorerGenerator))
	
	var List<EntityData> features = null
	
	override void doGenerate(Resource resource, IFileSystemAccess fsa) {
		
		val analyisName = resource.analysisName
		val headerFile = analyisName + '.h'
		val codeFile = analyisName + '.c'
		val javaFile = analyisName + '.java'
		
		features = resource.allContents.filter(typeof(EntityData)).filter[
				it.name!="membership" && it.name!="on_inclusion" && it.name!="root_objects"
				].toList
		
		if (!analyisName.contains("simple")) return;
		
		// Java Code
		fsa.generateFile(analyisName +'/' + javaFile, resource.javaCode(analyisName))
		
		// c code
		fsa.generateFile(analyisName +'/' + headerFile, resource.header(analyisName))
		fsa.generateFile(analyisName +'/' + codeFile, resource.code(analyisName))
	}
	
	def analysisName(Resource resource) {
		val exp = resource.allContents.filter(typeof(GlobalProperty)).findFirst[name=='name'].value
		val type = exp.type
		if (type.equals(HETypeFactory::stringType)) {
			val c = exp.constant
			if (c instanceof String) c.toString.replace(" ","_")
			else {
				//'noname'
				val i  = resource.URI.path.lastIndexOf("/")
				resource.URI.path.substring(i+1).replace(" ","_")
			}
		}
		else {
			val i  = resource.URI.path.lastIndexOf("/")
			resource.URI.path.substring(i+1).replace(" ","_")
		}
	} 
	
	def CharSequence javaCode(Resource resource, String className)'''
		package «className»;
		import java.util.*;
		public class «className» {
			
			// fields
			«FOR d : features»
				public «d.type.type.java_declare_var» «d.name»;
			«ENDFOR»
			
			// constructor
			public «className»(
				«FOR d : features SEPARATOR ','»
				«d.type.type.java_declare_var» «d.name»
				«ENDFOR»
			)
			{
				«FOR d : features»
				this.«d.name» = «d.name»;
				«ENDFOR»
			}
		}
		«FOR t: resource.allContents.filter(typeof(Type)).filter[t|t.name!= null && !(t instanceof BaseType)].toIterable»
		«IF t.type instanceof ComposedType»
		// type definition for «t.name»
		class «t.type.name» {
			«FOR f : (t.type as ComposedType).fields»
			public «f.value.java_declare_var» «f.key»;
			«ENDFOR»
			// constructor
			public «t.type.name»(
				«FOR f : (t.type as ComposedType).fields SEPARATOR ','»
				«f.value.java_declare_var» «f.key» 
				«ENDFOR»
			)
			{
				«FOR f: (t.type as ComposedType).fields»
				this.«f.key» = «f.key»;
				«ENDFOR»
			}
		}
		«ENDIF»
		«ENDFOR»
		'''
	
	def CharSequence header(Resource resource, String f)'''
		#ifndef __«f.toUpperCase»__
		#define __«f.toUpperCase»__
		
		// user-defined types
		«FOR t: resource.allContents.filter(typeof(Type)).filter[t|t.name!= null && !(t instanceof BaseType)].toIterable»
		// type definition for «t.name»
		«t.c_representation»
		«ENDFOR»
		
		//this structure represents the data on each resource principal
		typedef struct {
		«FOR d : features»
			«d.type.name» «d.name»;
		«ENDFOR»
		} «ConstantValuesForGeneration::PRINCIPAL_DATA»;
		
		#include<stdio.h>
		#include<stdlib.h>
		#include<stdbool.h>
		#include<string.h>
		
		#include "common.h"
		#include "RuntimeObjects.h"
		
		#include "jni.h"
		#include "jvmti.h"
		
		extern ResourcePrincipalType TYPES[];
		
		extern int nbTYPES;
		
		jobject localCreateResults
			(jvmtiEnv* jvmti, JNIEnv * jniEnv, void* user_data);
		
		#endif
		'''
	
	def CharSequence code(Resource resource, String analysis_name)'''
		#include "list.h"
		#include "«analysis_name».h"
		
		// methods to initialize properties
		«FOR c : resource.allContents.filter(typeof(ComponentType)).toIterable BEFORE '\n'»
			«c.compile_to_c»
		«ENDFOR»
		
		// methods to obtain instances' names
		«FOR ins : resource.allContents.filter(typeof(Instance)).toIterable SEPARATOR ',' »
			«ins.compile_to_c»
		«ENDFOR»
		
		// routines to initialize user-defined functions
		«FOR c : resource.allContents.filter(typeof(ComponentType)).toIterable BEFORE '\n'»
			void «c.name»_initialize
				(EntityEnvironment* env, 
				void* ud)
			{
				«ConstantValuesForGeneration::PRINCIPAL_DATA»* princ =
						(«ConstantValuesForGeneration::PRINCIPAL_DATA»*)ud;
				«FOR p: c.properties.filter[
					it.property.name!="membership" && it.property.name!="on_inclusion" && it.property.name!="root_objects"]»
				princ->«p.property.name» = «c.name»_«p.property.name»(env,princ);
				«ENDFOR»
			}
		«ENDFOR»
		
		// method to create new instances of ResourcePrincipalData
		void* instances_createResourcePrincipalData()
		{
			return calloc(sizeof(«ConstantValuesForGeneration::PRINCIPAL_DATA»), 1);
		}
		
«««		FIXME: This doesn't work if there is a type X and a type table-of X, then a data y:table-of X but no data of type X
		«features.routine_to_create_main_result(analysis_name)»
		
		jobject localCreateResults
		(jvmtiEnv* jvmti, JNIEnv * jniEnv, void* user_data)
		{
			InnerPrincipal* iPrinc = (InnerPrincipal*)user_data;
			ResourcePrincipalData* data = (ResourcePrincipalData*)iPrinc->princ;
			jobject finalResult = create_«analysis_name»_ResourcePrincipalData(jniEnv, data);
					
			return finalResult;
		}
		
		// ResourcePrincipalTypes
		ResourcePrincipalType TYPES[] = {
		«FOR ins : resource.allContents.filter(typeof(Instance)).toIterable SEPARATOR ',' »
			{ 
			  instances_createResourcePrincipalData,
			  «IF ins.names.type.equals(HETypeFactory::stringType)»«ins.name.name»_init_names«ELSE»0«ENDIF», 
			  «IF HETypeFactory::isCollectionOf(ins.names.type, HETypeFactory::stringType)»«ins.name.name»_init_names«ELSE»0«ENDIF», 
			  «ins.name.name»_«"root_objects"»,
			  «ins.name.name»_«"membership"»,
			  «ins.name.name»_«"on_inclusion"»,
			  «ins.name.name»_initialize
			}
		«ENDFOR»
		};
		
		int nbTYPES = «resource.allContents.filter(typeof(Instance)).size»;
	'''
	
}

/*
 * generated by Xtext
 */
package org.xtext.heapexplorer.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.IGenerator
import org.eclipse.xtext.generator.IFileSystemAccess
import org.xtext.heapexplorer.heapExplorer.Type
import org.xtext.heapexplorer.heapExplorer.BaseType
import org.xtext.heapexplorer.heapExplorer.StructType
import org.xtext.heapexplorer.heapExplorer.TableType
import org.xtext.heapexplorer.heapExplorer.EntityData
import org.xtext.heapexplorer.heapExplorer.GlobalProperty
import org.xtext.heapexplorer.heapExplorer.StringLiteral
import org.apache.log4j.Logger
import org.xtext.heapexplorer.validation.ExpressionsTypeProvider
import javax.inject.Inject
import org.xtext.heapexplorer.types.HETypeFactory
import org.xtext.heapexplorer.validation.ConstantValueExpressionProvider
import org.xtext.heapexplorer.validation.CachedExpressionsTypeProvider
import org.xtext.heapexplorer.heapExplorer.ComponentType
import org.xtext.heapexplorer.heapExplorer.Expression
import org.xtext.heapexplorer.heapExplorer.ComponentProperty
import org.xtext.heapexplorer.heapExplorer.Instance
import org.xtext.heapexplorer.types.CollectionType
import org.xtext.heapexplorer.types.ComposedType
import org.xtext.heapexplorer.types.HeapExplorerType

/**
 * Generates code from your model files on save.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#TutorialCodeGeneration
 */
class HeapExplorerGenerator implements IGenerator {
	
	
	@Inject extension CachedExpressionsTypeProvider
	@Inject extension ConstantValueExpressionProvider
	@Inject extension ExtensionExpressionCompilationProvider
	
	private static final Logger log = Logger.getLogger(typeof(HeapExplorerGenerator))
	
	
	override void doGenerate(Resource resource, IFileSystemAccess fsa) {
		
		val analyisName = resource.analysisName
		val headerFile = analyisName + '.h'
		val codeFile = analyisName + '.c'
		val javaFile = analyisName + '.java'
		
		// c code
		fsa.generateFile(analyisName +'/' + headerFile, resource.header(analyisName))
		fsa.generateFile(analyisName +'/' + codeFile, resource.code(headerFile))
		
		// Java Code
		fsa.generateFile(analyisName +'/' + javaFile, resource.javaCode(analyisName))
	}
	
	def analysisName(Resource resource) {
		val exp = resource.allContents.filter(typeof(GlobalProperty)).findFirst[name=='name'].value
		val type = exp.type
		if (type.equals(HETypeFactory::stringType)) {
			val c = exp.constant
			if (c instanceof String) c.toString.replace(" ","_")
			else {
				//'noname'
				val i  = resource.URI.path.lastIndexOf("/")
				resource.URI.path.substring(i+1).replace(" ","_")
			}
		}
		else {
			val i  = resource.URI.path.lastIndexOf("/")
			resource.URI.path.substring(i+1).replace(" ","_")
		}
	} 
	
	def CharSequence javaCode(Resource resource, String className)'''
		package «className»;
		public class «className» {
			«FOR t: resource.allContents.filter(typeof(Type)).filter[t|t.name!= null && !(t instanceof BaseType)].toIterable»
			// type definition for «t.name»
			«t.getJavaRepresentation»
			«ENDFOR»
			
			// fields
			«FOR d : resource.allContents.filter(typeof(EntityData)).filter[
				it.name!="membership" && it.name!="on_inclusion" && it.name!="root_objects"
				].toIterable»
				«d.type.type.declare_var» «d.name»«IF d.type.type instanceof CollectionType» = new ArrayList<«d.type.type.name»>()«ENDIF»;
			«ENDFOR»
		}
		'''
	
	def String getJavaRepresentation(Type type) {
		val heType = type.type
		switch(heType) {
			ComposedType:'''class «heType.name»{
				«FOR f: (heType as ComposedType).fields»
					«f.value.declare_var» «f.key»«IF f.value instanceof CollectionType» = new ArrayList<«f.value.name»>()«ENDIF»;
				«ENDFOR»
			}'''
			default:''''''
		}
	}
	
	def declare_var(HeapExplorerType type) {
		switch(type) {
			CollectionType:'''List<«type.name»>'''
			default:'''«type.name»'''
		}
	}
	
	def CharSequence header(Resource resource, String f)'''
		#ifndef __«f.toUpperCase»__
		#define __«f.toUpperCase»__
		
		// user-defined types
		«FOR t: resource.allContents.filter(typeof(Type)).filter[t|t.name!= null && !(t instanceof BaseType)].toIterable»
		// type definition for «t.name»
		«t.c_representation»
		«ENDFOR»
		
		//this structure represents the data on each resource principal
		typedef struct {
		«FOR d : resource.allContents.filter(typeof(EntityData)).filter[
			it.name!="membership" && it.name!="on_inclusion" && it.name!="root_objects"
		].toIterable»
			«d.type.name» «d.name»;
		«ENDFOR»
		} «ConstantValuesForGeneration::PRINCIPAL_DATA»;
		
		#include "common.h"
		#include "RuntimeObjects.h"
		
		extern ResourcePrincipalType TYPES[];
		
		extern int nbTYPES;
		
		#endif
		'''
	
	def CharSequence code(Resource resource, String headerFile)'''
		#include "list.h"
		#include "«headerFile»"
		
		// methods to initialize properties
		«FOR c : resource.allContents.filter(typeof(ComponentType)).toIterable BEFORE '\n'»
			«c.compile_to_c»
		«ENDFOR»
		
		// methods to obtain instances' names
		«FOR ins : resource.allContents.filter(typeof(Instance)).toIterable SEPARATOR ',' »
			«ins.compile_to_c»
		«ENDFOR»
		
		// routines to initialize user-defined functions
		«FOR c : resource.allContents.filter(typeof(ComponentType)).toIterable BEFORE '\n'»
			void «c.name»_initialize
				(EntityEnvironment* env, 
				void* ud)
			{
				«ConstantValuesForGeneration::PRINCIPAL_DATA»* princ =
						(«ConstantValuesForGeneration::PRINCIPAL_DATA»*)ud;
				«FOR p: c.properties.filter[
					it.property.name!="membership" && it.property.name!="on_inclusion" && it.property.name!="root_objects"]»
				princ->«p.property.name» = «c.name»_«p.property.name»(env,princ);
				«ENDFOR»
			}
		«ENDFOR»
		
		// method to create new instances of ResourcePrincipalData
		void* instances_createResourcePrincipalData()
		{
			return calloc(sizeof(«ConstantValuesForGeneration::PRINCIPAL_DATA»), 1);
		}
		
		// ResourcePrincipalTypes
		ResourcePrincipalType TYPES[] = {
		«FOR ins : resource.allContents.filter(typeof(Instance)).toIterable SEPARATOR ',' »
			{ 
			  instances_createResourcePrincipalData,
			  «IF ins.names.type.equals(HETypeFactory::stringType)»«ins.name.name»_init_names«ELSE»0«ENDIF», 
			  «IF HETypeFactory::isCollectionOf(ins.names.type, HETypeFactory::stringType)»«ins.name.name»_init_names«ELSE»0«ENDIF», 
			  «ins.name.name»_«"root_objects"»,
			  «ins.name.name»_«"membership"»,
			  «ins.name.name»_«"on_inclusion"»,
			  «ins.name.name»_initialize
			}
		«ENDFOR»
		};
		
		int nbTYPES = «resource.allContents.filter(typeof(Instance)).size»;
	'''
	
}

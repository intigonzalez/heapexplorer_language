/*
 * generated by Xtext
 */
package org.xtext.heapexplorer.scoping

import org.xtext.heapexplorer.heapExplorer.TableType
import org.eclipse.xtext.scoping.IScope
import org.eclipse.emf.ecore.EReference
import org.apache.log4j.Logger
import org.eclipse.xtext.scoping.impl.SimpleScope
import org.eclipse.xtext.resource.EObjectDescription
import java.util.ArrayList
import org.eclipse.xtext.resource.IEObjectDescription
import org.xtext.heapexplorer.heapExplorer.HeapExplorerFactory
import org.eclipse.xtext.naming.QualifiedName
import org.xtext.heapexplorer.heapExplorer.Field
import org.xtext.heapexplorer.heapExplorer.BaseType
import org.xtext.heapexplorer.heapExplorer.EntityData
import org.xtext.heapexplorer.heapExplorer.Type
import org.xtext.heapexplorer.heapExplorer.HeapExplorer
import org.eclipse.emf.ecore.EObject
import org.eclipse.xtext.scoping.impl.FilteringScope
import org.eclipse.xtend.expression.Resource
import org.xtext.heapexplorer.types.HETypeFactory
import org.xtext.heapexplorer.types.HeapExplorerType
import org.xtext.heapexplorer.types.CollectionType
import org.xtext.heapexplorer.heapExplorer.HeapExplorerPackage
import org.xtext.heapexplorer.types.ComposedType
import java.util.Objects

/**
 * This class contains custom scoping description.
 * 
 * see : http://www.eclipse.org/Xtext/documentation.html#scoping
 * on how and when to use it 
 *
 */
class HeapExplorerScopeProvider extends org.eclipse.xtext.scoping.impl.AbstractDeclarativeScopeProvider {
	
	private static final Logger log = Logger.getLogger(typeof(HeapExplorerScopeProvider));
	
	val builtinType = new ArrayList<Type>
	val descriptions = new ArrayList<IEObjectDescription>()
	
	def fill( ArrayList<Type> types ) {
		
		types.clear
		
		for (x : HETypeFactory.builtInTypes)
			types.add(x.EMFType(types))
	}
	
	def Type EMFType(HeapExplorerType x, ArrayList<Type> types) {
		val t = HeapExplorerFactory.eINSTANCE.createBaseType
		t.name = x.name
		t
	}
	
	override IScope getScope(EObject context, EReference reference) {
		val IScope p = super.getScope(context, reference)
		if (context instanceof TableType || 
			context instanceof Field || 
			context instanceof EntityData
		) {
			val HeapExplorer he = context.eResource.allContents.filter(typeof(HeapExplorer)).findFirst[true]
			if (!he.types.exists[it.name != null && it.name == HETypeFactory.intType.name ]) {
				fill(builtinType)
				descriptions.clear
				for (t : builtinType) {
					he.types.add(t)
					descriptions.add(new EObjectDescription(QualifiedName.create(t.name), t, null))
				}
			}
			val fi = new ArrayList<IEObjectDescription>(descriptions)
			return new SimpleScope(p, fi)
		}
		return p
	}
}
